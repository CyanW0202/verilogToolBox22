


`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/14/2022 11:07:55 AM
// Design Name: 
// Module Name: bitCount
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module bitCount(clock, reset, ready, dataA, count, done, CA, AN);
input clock, reset, ready;
input [3:0] dataA; 
output reg [2:0] count;
output reg done, CA, AN;

endmodule

module bits(clock, reset, ready, dataA, count, done);
localparam n=4;
input clock, reset, ready;
input [n-1:0] dataA; 
output reg [n-1:0] count;
output reg done;
reg [1:0] state_reg;
localparam [1:0] s1=2'b01, s2=2'b10, s3=2'b11;
reg [1:0] state_next;
reg [n-1:0] registerA, registerA_next;
reg [n-1:0] count_next;//log2(n), but I just calculate it
reg done_next;
//wire outsignal;
//slowerClkGen clockG(clock, 1, outsignal);
always @(posedge clock)
       if (reset)
          begin
             state_reg <= s1; //state_reg = 01
             count<=2'b00;
             registerA<=0;//registerA = 0x0000
             done=1'b0;
          end
       else
          begin
             state_reg <= state_next; 
             count<=count_next;
             registerA<=registerA_next;
             done<= done_next;
          end
always @(*)
begin
    state_next = state_reg; //state_next = 01
    count_next=count;// count_next=0000, max = 1010 = d10.
    registerA_next=registerA;//rA_next = 0000 for reset.
    done_next=done;//done = 0, done_next = 0;
    case (state_reg)//state_reg = s1
    s1:
    begin
       if (ready==1)//if input ready == 1
         begin
           state_next=s2;//go to s2.
           done_next=0;//not yet done.
         end
       else
         begin
           registerA_next =dataA;//if user is not ready, load rA_next = A
           done_next = 0;//stay here
         end
    end
    s2:
    begin
       if (registerA==0)
         begin
           state_next=s3;
         end
       else
        begin
         if (registerA_next[0]==1'b1)
          begin
            count_next<= count + 1;
          end
         else //can be omitted
          begin
           count_next = count;
          end
        end
        registerA_next=registerA>>1;
    end
    s3:
    begin
      done_next=1;
      if(ready == 0)
      begin
        state_next = s1;
        count_next = 0;
      end
    end
    default:
    begin
        state_next = s1; 
        done_next=0;
    end
    endcase
end     
endmodule

module slowerClkGen(input clk, resetA, output outsignal, type);
reg [17:0] counter = 0;
reg [27:0] counter2 = 0;  
reg outsignal = 0;
reg type;
initial begin
type = 1;
end
    always @ (posedge clk) //synchronous reset, clk = 0 when reset is 0.
    begin
       if (resetA)
        begin
            counter=0;
            outsignal=0;
        end
        else
        begin
            counter = counter +1; //every positive edge of clock would +1
            counter2 = counter2 +1;
            if (counter == 125_000) //every 1s toggle, -+- is a wave, toggle twice, so T = 2.5ms, f = 400Hz
            begin
                outsignal=~outsignal;
                counter =0;
            end
            if (counter2 == 100_000_000) //every 1s toggle, -+- is a wave, toggle twice, so T = 1s, f = 1Hz
            begin
                counter2 =0;
                type = ~type;
            end
            
         end
    end
endmodule

`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/08/2022 01:49:40 PM
// Design Name: 
// Module Name: Multiplier_test
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module bitCount_test;
reg clk, rset, command;
reg [3:0] dA; 
wire [3:0] cnt;
wire d;
bitcount uut(clk, rset, command, dA, cnt, d);
initial begin
#1 rset=0;clk=0;
#1 clk=~clk;
#1 rset=1; dA=4'b1101; clk=~clk;
#1 clk=~clk;
#1 clk=~clk;
#1 rset=0; clk=~clk;
#1 command=1;  clk=~clk;
repeat(15)
#1 clk=~clk;

#1 command = 0; rset = 1; dA = 4'b1000; clk = ~clk;
#1 clk = ~clk;
#1 clk = ~clk;rset = 0;
#1 clk = ~clk;
#1 command = 1;  clk = ~clk;
repeat(15)
#1 clk=~clk;


end
