`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/08/2022 01:44:37 PM
// Design Name: 
// Module Name: Multiplier
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/14/2022 11:07:55 AM
// Design Name: 
// Module Name: bitCount
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module bitCount(clock, reset, ready, dataA, count, done, CA, AN);
input clock, reset, ready;
input [3:0] dataA; 
output reg [2:0] count;
output reg done, CA, AN;

endmodule

module bits(clock, reset, ready, dataA, count, done);
localparam n=4;
input clock, reset, ready;
input [n-1:0] dataA; 
output reg [2:0] count;
output reg done;
reg [1:0] state_reg;
localparam [1:0] s1=2'b01, s2=2'b10, s3=2'b11;
reg [1:0] state_next;
reg [2*n-1:0] registerA, registerA_next;
reg [2:0] count_next;//log2(n), but I just calculate it
reg done_next;
wire outsignal;
slowerClkGen clockG(clock, 1, outsignal);
always @(posedge outsignal)
       if (reset)
          begin
             state_reg <= s1;
             count<=2'b00;
             registerA<=0;
             done=1'b0;
          end
       else
          begin
             state_reg <= state_next;
             count<=count_next;
             registerA<=registerA_next;
             done<= done_next;
          end
always @(*)
begin
    state_next = state_reg; 
    count_next=count;
    registerA_next=registerA;
    done_next=done;
    case (state_reg)
    s1:
    begin
       if (ready==1)
         begin
           state_next=s2;
           done_next=0;
         end
       else
         begin
           registerA_next =dataA;
           done_next = 0;
         end
    end
    s2:
    begin
       if (registerA==0)
         begin
           state_next=s3;
         end
       else
        begin
         if (registerA_next[0]==1'b1)
          begin
            count_next<= count + 1;
          end
         else //can be omitted
          begin
           count_next = count;
          end
        end
        registerA_next=registerA<<1;
    end
    s3://?????
    begin
      done_next=1;
      if(ready == 0)
        state_next = s1;
     count_next = 0;
    end
    default:
    begin
        state_next = s1; 
        done_next=0;
    end
    endcase
end     
endmodule

module slowerClkGen(input clk, resetA, output outsignal, type);
reg [17:0] counter = 0;
reg [27:0] counter2 = 0;  
reg outsignal = 0;
reg type;
initial begin
type = 1;
end
    always @ (posedge clk) //synchronous reset, clk = 0 when reset is 0.
    begin
       if (resetA)
        begin
            counter=0;
            outsignal=0;
        end
        else
        begin
            counter = counter +1; //every positive edge of clock would +1
            counter2 = counter2 +1;
            if (counter == 125_000) //every 1s toggle, -+- is a wave, toggle twice, so T = 2.5ms, f = 400Hz
            begin
                outsignal=~outsignal;
                counter =0;
            end
            if (counter2 == 100_000_000) //every 1s toggle, -+- is a wave, toggle twice, so T = 1s, f = 1Hz
            begin
                counter2 =0;
                type = ~type;
            end
            
         end
    end
endmodule

`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/08/2022 01:49:40 PM
// Design Name: 
// Module Name: Multiplier_test
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module bitCount_test;
reg clock, reset, command;
reg [3:0] dataA;
wire done;
wire [2:0] dataB;
bits uut(clock, reset, command, dataA, dataB, done);
initial begin
#1 reset=0;clock=0;
#1 clock=~clock;
#1 reset=1; dataA=4'b1101; clock=~clock;
#1 clock=~clock;
#1 clock=~clock;
#1 reset=0; clock=~clock;
#1 command=1;  clock=~clock;
repeat(10)
#1 clock=~clock;
end
endmodule
