`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/23/2022 02:05:33 PM
// Design Name: 
// Module Name: ASMD
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module ASMD( );

endmodule

module stateMachine(clock, reset, ready, dataB, bito, done);
localparam n=8;
input clock, reset, ready;
input [n-1:0] dataB;
output reg done, bito;

reg [1:0] state_reg;
reg [2:0] counter;
reg [3:0] bitcount;
localparam [1:0] s1=2'b01, s2=2'b10, s3=2'b11;
reg [1:0] state_next;
reg [n-1:0] registerB, registerB_next;
reg [2*n-1:0] bito_next;
reg done_next;
//initial begin
//product = 0;
//state_reg = 0;
//end

always @(posedge clock)
       if (reset)
          begin
             state_reg <= s1;
             bito<=0;
             registerB<=0;
             counter = 0;
             bitcount = 0;
             done=0;
          end
       else
          begin
             state_reg <= state_next;
             bito<=bito_next;
             registerA<=registerA_next;
             registerB<=registerB_next;
             done<= done_next;
          end
always @(*)
begin
    state_next = state_reg; 
    product_next=product;
    registerA_next=registerA;
    registerB_next=registerB;
    done_next=done;
    case (state_reg)
    s1:
    begin
       if (command==1)
         begin
           state_next=s2;
           done_next=0;
         end
       else
         begin
           registerA_next ={4'b0, dataA};
           registerB_next =dataB;
         end
    end
    s2:
    begin
       if (registerB==0)
         begin
           state_next=s3;
         end
       else
        begin
         if (registerB_next[0]==1'b1)
          begin
            product_next<= product + registerA;
          end
         else //can be omitted
          begin
           product_next = product;
          end
        end
        registerA_next=registerA<<1;
        registerB_next=registerB>>1;
    end
    s3:
    begin
      done_next=1;
      if (command==0)
         state_next=s1;
    end
    
    default:
    begin
        state_next = s1; 
        done_next=0;
    end
    endcase
end
endmodule




`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/14/2022 11:07:55 AM
// Design Name: 
// Module Name: bitCount
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module bitCount(input clock, rA, s, [3:0]data, output d, [6:0]CA1, [7:0]AN1);
wire outsignal, twosec;
wire [1:0] Qp, Qd;
wire [3:0] Qs, Qm;
slowerClkGen clking(clock, 1'b0, outsignal, twosec);
upcounter counting(outsignal, Qp);
bit bitc(twosec, rA, s, data, Qm, d);
muxdisplay display(d, outsignal, Qm, CA1, AN1);
endmodule

module muxdisplay(input en, fastr, [3:0]counterCAm, output [6:0]CA, reg [7:0] AN);
reg [3:0] num;
always@(*)
begin
   num = (en)?counterCAm:4'b1111;
   AN = 8'b1111_1110;
end    
segment7_control CAcontrol(num, CA);
endmodule


module segment7_control(input[3:0]num, output reg [6:0]C);
    always@(num)
    begin
        case(num)
            0: C = 1;
            1: C = 7'b1001111; //4F
            2: C = 7'b0010010;//12
            3: C = 7'b0000110;//06
            4: C = 7'b1001100;//4C
            5: C = 7'b0100100;//24
            6: C = 7'b0100000;//20
            7: C = 7'b0001111;//0F
            8: C = 0;
            9: C = 7'b0001100;//0C
            4'b1111: C = ~7'b0001110;//000
        endcase
    end
endmodule

module upcounter (input Clock, output[1:0] Qc); //to output a 2 bits selector
reg [1:0] Qc = 0;
always @(posedge Clock) //Q = 0 when reset is 0.
begin
    
        Qc <= Qc + 1;//Q = 0~3
end
endmodule

module bit(clock, reset, ready, dataA, count, done);
localparam n=4;
input clock, reset, ready;
input [n-1:0] dataA; 
output reg [n-1:0] count;
output reg done;
reg [1:0] state_reg;
localparam [1:0] s1=2'b01, s2=2'b10, s3=2'b11;
reg [1:0] state_next;
reg [2*n-1:0] registerA, registerA_next;
reg [n-1:0] count_next;//log2(n), but I just calculate it
reg done_next;
//wire outsignal;
//slowerClkGen clockG(clock, 1, outsignal);
always @(posedge clock)
       if (reset)
          begin
             state_reg <= s1; //state_reg = 01
             count<=0;
             registerA <=0;//registerA = 0x0000
             done=1'b0;
          end
       else
          begin
             state_reg <= state_next; 
             count<=count_next;//count next = 0??
             registerA<=registerA_next;
             done<= done_next;
          end
always @(*)
begin
    state_next = state_reg; //state_next = 01
    count_next=count;// count_next=0000, max = 1010 = d10.; count next = 0
    registerA_next=registerA;//rA_next = 0000 for reset.
    done_next=done;//done = 0, done_next = 0;
    case (state_reg)//state_reg = s1
    s1:
    begin
       if (ready==1)//if input ready == 1
         begin
           state_next=s2;//go to s2.
           done_next=0;//not yet done.
         end
       else
         begin
           registerA_next ={4'b0, dataA};//if user is not ready, load rA_next = A
           done_next = 0;//stay here
         end
    end
    s2:
    begin
       if (registerA==0)
         begin
           state_next=s3;
         end
       else
        begin
         if (registerA_next[0]==1'b1)
          begin
            count_next <= count + 1;
          end
        end
        registerA_next=registerA>>1;
    end
    s3:
    begin
      done_next=1;
      if(ready == 0)
      begin
        state_next = s1;
      end
    end
    default:
    begin
        state_next = s1; 
        done_next=0;
    end
    endcase
end     
endmodule

module slowerClkGen(input clk, resetA, output outsignal, type);
reg [17:0] counter = 0;
reg [27:0] counter2 = 0;  
reg outsignal = 0;
reg type;
initial begin
type = 1;
end
    always @ (posedge clk) //synchronous reset, clk = 0 when reset is 0.
    begin
       if (resetA)
        begin
            counter=0;
            outsignal=0;
        end
        else
        begin
            counter = counter +1; //every positive edge of clock would +1
            counter2 = counter2 +1;
            if (counter == 125_000) //every 1s toggle, -+- is a wave, toggle twice, so T = 2.5ms, f = 400Hz
            begin
                outsignal=~outsignal;
                counter =0;
            end
            if (counter2 == 100_000_000) //every 1s toggle, -+- is a wave, toggle twice, so T = 2s, f = 1/2Hz
            begin
                counter2 =0;
                type = ~type;
            end
            
         end
    end
endmodule



`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 11/08/2022 01:49:40 PM
// Design Name: 
// Module Name: Multiplier_test
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module bitCount_test;
reg clk, rset, command;
reg [3:0] dA; 
wire [3:0] cnt;
wire d;
bitcount uut(clk, rset, command, dA, cnt, d);
initial begin
#1 rset=0;clk=0;
#1 clk=~clk;
#1 rset=1; dA=4'b1101; clk=~clk;
#1 clk=~clk;
#1 clk=~clk;
#1 rset=0; clk=~clk;
#1 command=1;  clk=~clk;
repeat(15)
#1 clk=~clk;

#1 command = 0; rset = 1; dA = 4'b1000; clk = ~clk;
#1 clk = ~clk;
#1 clk = ~clk;rset = 0;
#1 clk = ~clk;
#1 command = 1;  clk = ~clk;
repeat(15)
#1 clk=~clk;


end
